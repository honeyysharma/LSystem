/// @file GLWindow.cpp
/// @brief basic implementation file for the GLWindow class

#include "GLWindow.h"
#include <iostream>
#include <ngl/Vec3.h>
#include <ngl/Light.h>
#include <ngl/NGLInit.h>
#include <ngl/VAOPrimitives.h>
#include <ngl/Material.h>
#include <ngl/ShaderLib.h>
#include <QColorDialog>
#include <iostream>


//----------------------------------------------------------------------------------------------------------------------
GLWindow::GLWindow(
                   QWidget *_parent
                   ) : QGLWidget( new CreateCoreGLContext(QGLFormat::defaultFormat()), _parent )

{

  // set this widget to have the initial keyboard focus
  setFocus();
  // re-size the widget to that of the parent (in this case the GLFrame passed in on construction)
  this->resize(_parent->size());

  //set this to false for first time
  isLSystemGenerated = false;
}

// This virtual function is called once before the first call to paintGL() or resizeGL(),
//and then once whenever the widget has been assigned a new QGLContext.
// This function should set up any required OpenGL context rendering flags, defining display lists, etc.

//----------------------------------------------------------------------------------------------------------------------
void GLWindow::initializeGL()
{

  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);			   // Black Background
  // enable depth testing for drawing
  glEnable(GL_DEPTH_TEST);
  std::cout<<"ngl init\n";
  ngl::NGLInit *init = ngl::NGLInit::instance();
  #ifdef WIN32
    glewInit();
  #endif
  init->initGlew();

}

//This function is called whenever parameters for LSystem change.

void GLWindow::calculateVertices()
{
    m_LSystem = m_LSystemParser.getLSystemWithFilename(m_filename);
    m_LSystem->expandGrammar(m_generations);
    m_currentString = m_LSystem->getCurrentString();

    // remove the previous vertices data for every call
    m_vertices.erase(m_vertices.begin(),m_vertices.end());

    LSystemState _presentState(m_position,m_headingAngle);
    LSystemState _previousState;

    //http://stackoverflow.com/questions/1025072/opengl-l-system-rendering

    //iterate over the current string generated by L System

    std::string::iterator _iterator;
    for (_iterator = m_currentString.begin() ; _iterator <= m_currentString.end(); _iterator++)
    {
        switch(*_iterator)
        {
            case 'F':
            case 'G':
            {
                     //set previous state to present state
                    _previousState = _presentState;
                    _presentState.updatePosition(m_stepLength);

                    //push old and new vertices for drawing
                    m_vertices.push_back(_previousState.getPosition());
                    m_vertices.push_back(_presentState.getPosition());
                    break;
            }

            case 'f':
            {
                    _previousState = _presentState;
                    _presentState.updatePosition(m_stepLength);
                    break;
            }

            case '[':
            {
                //push present state (vertices and angle) into stack when branching is signalled.

                m_LSystemState.push(_presentState);
                break;
            }

            case ']':
            {
                //pop the top state and set is to present state

                _presentState = m_LSystemState.top();
                m_LSystemState.pop();

                break;
            }

            case '+':
            {
                //turn right by give angle

                _presentState.updateAngle(m_turnAngle);
                break;
            }

            case '-':
            {
                //turn left by given angle

                _presentState.updateAngle(-1 * m_turnAngle);
                break;
            }

            default:
                break;
        }
    }

    //http://stackoverflow.com/questions/7173494/vbos-with-stdvector

    // bind the data for drawing
    glGenBuffersARB(1, &VBOBuffers);

    glBindBufferARB(GL_ARRAY_BUFFER, VBOBuffers);
    glBufferDataARB(GL_ARRAY_BUFFER,
                 m_vertices.size() * sizeof(ngl::Vec3),
                 &m_vertices.front(),
                 GL_STATIC_DRAW);
    glBindBufferARB(GL_ARRAY_BUFFER, 0);
}

//----------------------------------------------------------------------------------------------------------------------
//This virtual function is called whenever the widget has been resized.
// The new size is passed in width and height.
void GLWindow::resizeGL(
                        int _w,
                        int _h
                       )
{
  glViewport(0,0,_w,_h);
}

//----------------------------------------------------------------------------------------------------------------------
//This virtual function is called whenever the widget needs to be painted.
// this is our main drawing routine
void GLWindow::paintGL()
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // enable  vertex array drawing
    glEnableClientState(GL_VERTEX_ARRAY);
    // bind our VBO data to be the currently active one
    glBindBufferARB(GL_ARRAY_BUFFER, VBOBuffers);

    //set color value for lines
    glColor4f(m_colour.m_x,m_colour.m_y,m_colour.m_z,1.0f);

    // tell GL how this data is formated in this case 3 floats tightly packed starting at the begining
    // of the data (0 = stride, 0 = offset)

    glVertexPointer(3,GL_FLOAT,0,0);
    // draw the VBO as a series of GL_LINES starting at 0 in the buffer and _vboSize*GLfloat
    glDrawArrays( GL_LINES, 0, m_vertices.size());
    // now turn off the VBO client state as we have finished with it
    glDisableClientState(GL_VERTEX_ARRAY);
}

//This is called to set initial heading angle of turtle
void GLWindow::setHeadingAngle(double _angle)
{
    m_headingAngle = _angle;
    if(isLSystemGenerated == true)
    {
        calculateVertices();
        updateGL();
    }
}

//This is called to set turn angle of turtle for branching
void GLWindow::setTurnAngle(double _angle)
{
    m_turnAngle = _angle;
    if(isLSystemGenerated == true)
    {
        calculateVertices();
        updateGL();
    }
}

//This is called to set number of generations for L System
void GLWindow::setGenerations(int _generations)
{
    m_generations = _generations;
    if(isLSystemGenerated == true)
    {
        calculateVertices();
        updateGL();
    }
}

//This is called to set step length between two vertices
void GLWindow::setStepLength(double _stepLength)
{
    m_stepLength = _stepLength;
    if(isLSystemGenerated == true)
    {
        calculateVertices();
        updateGL();
    }
}

//This is called to set initial position in x - coordinate
void GLWindow::setXPosition(double _x)
{
    m_position.m_x = _x;
    if(isLSystemGenerated == true)
    {
        calculateVertices();
        updateGL();
    }
}

//This is called to set initial position in y - coordinate
void GLWindow::setYPosition(double _y)
{
    m_position.m_y = _y;
    if(isLSystemGenerated == true)
    {
        calculateVertices();
        updateGL();
    }
}

//This is called to set initial position in z - coordinate
void GLWindow::setZPosition(double _z)
{
    m_position.m_z = _z;
    if(isLSystemGenerated == true)
    {
        calculateVertices();
        updateGL();
    }
}

//This is called to set colour of lines to be drawn
void GLWindow::setColour()
{
    QColor colour = QColorDialog::getColor();
    if( colour.isValid())
    {
        m_colour.m_x = colour.red();
        m_colour.m_y = colour.green();
        m_colour.m_z = colour.blue();

        if(isLSystemGenerated == true)
        {
            updateGL();
        }
    }
}

//This is called on Generate push button event from UI
void GLWindow::generateLSystem(QString _filename,
                               double _headingAngle,
                               double _turnAngle,
                               double _stepLength,
                               int _generations,
                               ngl::Vec3 _position,
                               ngl::Vec3 _colour)
{
    // check to see if LSystem is already generated or not to set the initial values
    if(isLSystemGenerated == false)
    {
        isLSystemGenerated = true;
        m_filename = _filename.toStdString();
        m_headingAngle = _headingAngle;
        m_turnAngle = _turnAngle;
        m_stepLength = _stepLength;
        m_generations = _generations;
        m_position= _position;
        m_colour = _colour;

        calculateVertices();
        updateGL();
    }
}


GLWindow::~GLWindow()
{
    delete m_LSystem;
}
